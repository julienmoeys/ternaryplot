% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/ternaryPlot.R
\name{ternaryPlot}
\alias{ternaryPlot}
\alias{ternaryPlot.character}
\alias{ternaryPlot.ternarySystem}
\title{Generic ternary-data plotting}
\usage{
ternaryPlot(s, ...)

\method{ternaryPlot}{character}(s, ...)

\method{ternaryPlot}{ternarySystem}(s, x = NULL, scale = FALSE, ...)
}
\arguments{
\item{s}{Either a character string naming the ternary classification
 system to be used (if pre-defined),
 or a \code{\link[ternaryplot]{ternarySystem}}-object,
 or a \code{ternaryPolygons}-object
 (such as created with \code{\link[ternaryplot]{createTernaryGrid}}).}

\item{x}{A \code{\link[base]{data.frame}} or a \code{\link[base]{matrix}}
 containing point ternary data (x-y-x) to be ploted on the graph.
 It should contain the 3 columns names given in \code{s}. If
 missing, only the ternary classification is drawn.}

\item{scale}{Either a logical value or a \code{\link[base]{data.frame}} with
 3 columns and 2 rows. If \code{TRUE}, the triangle plot will
 be scaled to fit the data. If \code{FALSE}, no scaling is
 performed, and the full extent triangle plot is drawn. If a
 \code{data.frame}, contains the min and max limits of each
 of the 3 variables (columns = variables, rows = min and max).}

\item{\dots}{Additional parameters passed to
 \code{\link[ternaryplot]{ternaryPoints}}}
}
\description{
Generic ternary-data plotting
}
\examples{

library( "ternaryplot" ) 

# Simple example, with point overlay
# ==================================

#   Save graphical parameters (to reset them later)
op <- par( no.readonly = TRUE ) 

#   Define the plot style (optional)
ternaryStyle( margin = TRUE ) 

#   Load an example dataset ( dummy example )
data( "textureDataset", package = "ternaryplot" ) 

#   Simple ternary plot with point overlay
ternaryPlot( 
    s   = "default", 
    x   = textureDataset[, c( "SAND", "CLAY", "SILT" ) ], 
    pch = textureDataset[, "GROUP" ] ) 



# Same example, with a ternary classification
# ===========================================

#   Simple ternary plot with point overlay
ternaryPlot( 
    s   = "hypres", 
    x   = textureDataset, 
    pch = textureDataset[, "GROUP" ] ) 

#   Notice that in the example above "hypres" classification 
#   *requires* columns named CLAY, SILT and SAND and 
#   will not take any other column names.



# Same example, with a ternary classification
# and custom column names for the texture classes
# ===========================================

#   Copy the dataset
textureDataset2 <- textureDataset[, c( "CLAY", "SILT", 
    "SAND", "GROUP" ) ]

#   Rename columns
colnames( textureDataset2 ) <- c( "clay", "silt", "sand", 
    "group" ) 

#   Fetch the definition of the ternary classification
hypres <- getTernarySystem( "hypres" ) 

#   Set the column names
#   Note: the order matter!
blrNames( hypres ) <- c( "sand", "clay", "silt" ) 

#   Set new labels
blrLabels( hypres ) <- c( "sand [\%]", "clay [\%]", "silt [\%]" ) 

#   Simple ternary plot with point overlay
ternaryPlot( 
    s   = hypres, 
    x   = textureDataset2, 
    pch = textureDataset2[, "group" ] )



# Vary the plot geometry
# ======================

# Prepare the plot layout
# -----------------------

#   Reset plot parameters
par( op )
tpPar( reset = TRUE )

#   Split the window in 4 sub-plots
par( mfrow = c(2,2) )

#   Set the plot style (optional)
ternaryStyle() 



# Default ternary plot
# --------------------

s <- ternaryPlot() 


# Change axis orientation (clockwise vs counter-clockwise)
# --------------------------------------------------------

#   Set new orientation
blrClock( s ) <- rep( FALSE, 3 ) 

#   Plot
ternaryPlot(s) 


# Change axis orientation and frame angles
# ----------------------------------------

#   Set new orientation and angles
blrClock( s )  <- c( FALSE, TRUE, NA ) 
tlrAngles( s ) <- c( 45, 90, 45 ) 

#   Plot
ternaryPlot(s) 


# Same, other direction
# ---------------------

blrClock( s ) <- c( TRUE, NA, FALSE ) 
tlrAngles( s ) <- c(45,45,90) 

ternaryPlot(s) 



#   reset par (completely)
par( op )
tpPar( reset = TRUE )
}

