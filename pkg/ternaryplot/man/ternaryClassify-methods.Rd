% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/ternaryClassify.R
\name{ternaryClassify}
\alias{ternaryClassify}
\alias{ternaryClassify.character}
\alias{ternaryClassify.ternaryPolygons}
\alias{ternaryClassify.ternarySystem}
\title{Classify ternary data (determine the class to which ternary data points belong)}
\usage{
ternaryClassify(s, x, ...)

\method{ternaryClassify}{character}(s, x, method = "over", ...)

\method{ternaryClassify}{ternarySystem}(s, x, method = "over", ...)

\method{ternaryClassify}{ternaryPolygons}(s, x, method = "over", ...)
}
\arguments{
\item{s}{Either \itemize{
   \item A \code{\link[ternaryplot]{ternarySystem-class}}.
     That \code{ternarySystem-class} must contain
     a ternary classification.
   \item A single character string, the name of an existing
     pre-defined \code{\link[ternaryplot]{ternarySystem-class}}.
   \item A \code{\link[ternaryplot]{ternaryPolygons-class}}.
 }}

\item{x}{A \code{\link[base]{data.frame}} or a
 \code{\link[base]{matrix}} containing point ternary data
 to be classified. It should contain the 3 columns
 names given by \code{blrNames(s)}. If missing, only the
 ternary classification is drawn.}

\item{method}{A single character string, naming the classification method
 to be used. Either \code{"over"}, in which case
 \code{\link[sp]{over}} is used, or \code{"point.in.polygon"},
 in which case \code{\link[sp]{point.in.polygon}} is used.
 The method influence the format and content of the output
 (see below).}

\item{\dots}{Additional parameters passed to specific methods.}
}
\value{
When \code{method} is \code{"over"}, a vector of character
 strings is returned, with the abbreviations of the
 ternary classes in which each ternary points falls. One
 value is returned per point, and when a point falls into
 several classes (i.e. a tie: the point lies in between two or
 more classes), \bold{the last class is returned}. This
 means that the order in which the classes are defined
 in \code{s} may influence the outcome of the classification.
 When \code{method} is \code{"point.in.polygon"}, a
 \code{\link[base]{matrix}} is returned, where each row is
 a data point and each column a ternary class, and each
 cell gives the output of \code{\link[sp]{point.in.polygon}}
 (\emph{"0: point is strictly exterior to pol; 1: point is
 strictly interior to pol; 2: point lies on the relative
 interior of an edge of pol; 3: point is a vertex of pol"}).
}
\description{
Classify ternary data (determine the class to which ternary
 data points belong)
}
\examples{

library( "ternaryplot" ) 

# Classify ternary points with a ternary classification
# =====================================================

#   Example with the HYPRES soil texture triangle

#   Load an example dataset ( dummy example )
data( "textureDataset", package = "ternaryplot" ) 

#   Classify the dataset
cls <- ternaryClassify( s = "hypres", x = textureDataset ) 

#   Tabular statistics
table( cls )

#   Classify the dataset (full details)
cls2 <- ternaryClassify( s = "hypres", x = textureDataset, 
    method = "point.in.polygon" ) 

#   View the output (1st rows)
head( cls2 )

#   Any point on an edge?
any( !(cls2 \%in\% 0:1 ) )



# Plot the result
# ---------------

#   Convert class (text) into integers, 'col'-codes
cols <- as.integer( factor( cls ) )

#   Save graphical parameters (to reset them later)
op <- par( no.readonly = TRUE ) 

#   Define the plot style (optional)
ternaryStyle( margin = TRUE ) 

#   Simple ternary plot with point overlay
ternaryPlot( s = "hypres", x = textureDataset, col = cols ) 



# Classify ternary points in a grid
# =================================

grd <- createTernaryGrid( s = "hypres" ) 

#   Classify the dataset
cls3 <- ternaryClassify( s = grd, x = textureDataset ) 

#   Calculate the counts per grid cells
counts <- as.integer( table( cls3 ) )
names( counts ) <- names( table( cls3 ) ) 
counts <- counts[ unique( grd[, "id" ] ) ] 
counts[ is.na( counts ) ] <- 0 

cols <- gray( 1 - counts / max( counts ) )

#   Simple ternary plot with point overlay
s <- ternaryPlot( s = "hypres" ) 
ternaryPolygons( s = grd, bg = cols )
ternaryPoints( s = s, x = textureDataset )



#   Reset plot parameters
par( op )
tpPar( reset = TRUE )


}
\seealso{
\code{\link[ternaryplot]{ternaryClasses}}, to extract
 the class polygons of a ternary classification from a
 \code{\link[ternaryplot]{ternarySystem-class}} as a
 \code{\link[ternaryplot]{ternaryPolygons-class}}.
}

